/*
 * Created on 13.12.2008
 *
 * To change the template for this generated file go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
package de.folt.models.datamodel;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import org.json.JSONArray;
import org.json.JSONObject;

import flexjson.JSONDeserializer;
import flexjson.JSONSerializer;
import flexjson.locators.TypeLocator;

/**
 * This class implements a MonoLingualObject, a object representing strings in a
 * specific language.<br> {@see <a
 * href="http://www.opentms.de/files/techspec.html">OpenTMS Software
 * Architecture</a>}.<br>
 * It extends a GeneralLinguisticObject.<br>
 * Its main components are: <br>
 * 
 * <pre>
 * formattedSegment = null; - the segment with all the format information available (e.g. TMX or XLIFF formats like <ph..>
 * language = null; the language associated with the segment
 * parentMultiLingualObject = null; MonoLingualObject(s) can be part of MultiLingualObjects; this is the reference to the parent MultiLingualObject. A MonoLingualObject can only belong to one  MultiLingualObject.
 * plainTextSegment = null; This is a version of the formattedSegment where all the formats (esp. <..> has been removed. This string is generated by supplying an appropriate method to the constructor of the MonoLingualObject.
 * </pre>
 * 
 * Other components are inherited from GeneralLinguisticObject {@see
 * de.folt.models.datamodel.GeneralLinguisticObject}.
 * 
 * @author klemens
 */

public class MonoLingualObject extends GeneralLinguisticObject implements Serializable
{

	/**
     * 
     */
	private static final long serialVersionUID = 5405252256461623066L;

	/**
	 * fromJson convert into a MonoLingualObject from JSON String
	 * 
	 * @param jsonMono
	 *            the json formatted string
	 * @return the MonoLingualObject
	 */
	public static MonoLingualObject fromJson(String jsonMono)
	{
		try
		{
			MonoLingualObject mono = new JSONDeserializer<MonoLingualObject>()
			// linguisticProperties
					.use("linguisticProperties", new TypeLocator<String>("linguisticProperties")
					// linguisticProperties
							.add("LinguisticProperty", de.folt.models.datamodel.LinguisticProperty.class))
					// MonoLingualObject.linguisticProperties
					.use("MonoLingualObject.linguisticProperties", de.folt.models.datamodel.LinguisticProperties.class)
					// MonoLingualObject.linguisticProperties
					.use("MonoLingualObject.linguisticProperties.keys", String.class)
					// MonoLingualObject.linguisticProperties
					.use("MonoLingualObject.linguisticProperties.values", de.folt.models.datamodel.LinguisticProperty.class)
					// deserialize
					.deserialize(jsonMono, MonoLingualObject.class);
			// get the linguistic properties separately
			JSONObject jMono = new JSONObject(jsonMono);
			String jlinguisticPropertiesString = jMono.getString("linguisticProperties");
			JSONObject jlinguisticProperties = new JSONObject(jlinguisticPropertiesString);
			@SuppressWarnings("rawtypes")
			java.util.Iterator it = jlinguisticProperties.keys();
			while (it.hasNext())
			{
				String key = (String) it.next();
				String value = jlinguisticProperties.getString(key);

				if (value.startsWith("[") && value.endsWith("]"))
				{
					value = "{\"" + key + "\":" + value + "}";
					System.out.println(value);
					JSONObject jValue = new JSONObject(value);
					@SuppressWarnings("rawtypes")
					java.util.Iterator itj = jValue.keys();
					while (itj.hasNext())
					{
						String keyj = (String) itj.next();
						JSONArray valuej = jValue.getJSONArray(keyj);
						for (int i = 0; i < valuej.length(); i++)
						{
							String jsvalueasjson = valuej.get(i).toString();
							LinguisticProperty linguisticProperty = LinguisticProperty.fromJson(jsvalueasjson);
							mono.addLinguisticProperty(linguisticProperty);
						}
					}
				}
				else
				{
					LinguisticProperty linguisticProperty = LinguisticProperty.fromJson(value);
					mono.addLinguisticProperty(linguisticProperty);
				}
			}
			return mono;
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * main
	 * 
	 * @param args
	 */
	public static void main(String[] args)
	{
		test();
	}

	/**
	 * simpleComputePlainText generates the a plain text version of a string.<br>
	 * 
	 * <pre>
	 * "Hallo <ph>bold</ph> house." ==>> "Hallo  house."
	 * </pre>
	 * 
	 * @param formattedText
	 *            the text with format inside (e.g. xml tags)
	 * @return the plain text.
	 */
	public static String simpleComputePlainText(String formattedText)
	{
		return simpleComputePlainText(formattedText, null);
	}

	/**
	 * simpleComputePlainText generates the a plain text version of a string.<br>
	 * 
	 * <pre>
	 * "Hallo <ph>bold</ph> house." ==>> "Hallo  house."
	 * </pre>
	 * 
	 * @param formattedText
	 *            the text with format inside (e.g. xml tags)
	 * @param arg
	 *            currently not used; future reserved to specify params for
	 *            removing format information
	 * @return the plain text.
	 */
	public static String simpleComputePlainText(String formattedText, Object arg)
	{
		if (formattedText == null)
			return null;
		String plaintext = formattedText;
		// very very simple replacement for xml ... no real checks done ...
		plaintext = plaintext.replaceAll("<.*?>.*?</.*?>", "");
		plaintext = plaintext.replaceAll("<.*?>", "");

		return plaintext;
	}

	/**
	 * test simple test method for generating some general linguistic objects
	 */
	public static void test()
	{
		try
		{
			MonoLingualObject mono1 = new MonoLingualObject("My small segment!", "en");
			mono1.addStringLinguisticProperty("OpenTMS", "Folt");
			System.out.println(mono1.toString());
			System.out.println(mono1.format());

			@SuppressWarnings("rawtypes")
			Class[] classes = new Class[2];
			classes[0] = String.class;
			classes[1] = Object.class;
			Method method = MonoLingualObject.class.getMethod("simpleComputePlainText", classes);

			MonoLingualObject mono2 = new MonoLingualObject("Mein kleiner Satz!", "de", MonoLingualObject.class, method, null);
			mono2.addStringLinguisticProperty("OpenTMS", "Folt");
			System.out.println(mono2.toString());
			System.out.println(mono2.format());

			MonoLingualObject mono3 = new MonoLingualObject("Mein kleiner formattierter <ph>cc</ph> Satz!", "de", MonoLingualObject.class, method,
					new Object());
			mono3.addStringLinguisticProperty("OpenTMS", "Folt");
			System.out.println(mono3.toString());
			System.out.println(mono3.format());

			System.out.println(mono1.bCompare(mono1));
			System.out.println(mono1.bCompare(mono2));
			System.out.println(mono1.bCompare(mono3));
			System.out.println(mono2.bCompare(mono3));

			MonoLingualObject mono4 = new MonoLingualObject("My small segment!", "en");
			mono4.addStringLinguisticProperty("OpenTMS", "Folt");
			System.out.println(mono1.bCompare(mono4));

			mono4.addStringLinguisticProperty("Araya", "Heartsome");
			System.out.println(mono1.bCompare(mono4));

			mono1.addStringLinguisticProperty("Araya", "Heartsome");
			System.out.println(mono1.bCompare(mono4));

			System.out.println(mono1.mapToJson());
			System.out.println(mono2.mapToJson());
			System.out.println(mono3.mapToJson());
			System.out.println("-----------------------------------------------------------------------------------");
			System.out.println(mono4.mapToJson());
			System.out.println("-----------------------------------------------------------------------------------");
			mono1.addStringLinguisticProperty("Araya", "Heartsome GmbH");

			System.out.println(mono1.format());
			String stmono1 = mono1.mapToJson();

			MonoLingualObject backmono1 = fromJson(stmono1);
			System.out.println(mono1.format());
			System.out.println(backmono1.format());

		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
     */
	protected String formattedSegment = "";

	/**
     */
	protected String language = "un";

	/**
     * 
     */
	protected MultiLingualObject parentMultiLingualObject = null;

	/**
     */
	protected String plainTextSegment = "";

	/**
     * 
     */
	public MonoLingualObject()
	{
		super();
		this.setFormattedSegment("");
		this.setPlainTextSegment("");
	}

	/**
	 * @param linguisticProperties
	 * @param lingType
	 * @param formattedSegment
	 * @param plainTextSegment
	 * @param language
	 */
	public MonoLingualObject(LinguisticProperties linguisticProperties, LinguisticTypes lingType, String formattedSegment, String plainTextSegment,
			String language)
	{
		super(linguisticProperties, lingType);
		this.setFormattedSegment(formattedSegment);
		this.setPlainTextSegment(plainTextSegment);
		this.language = language;
	}

	/**
	 * @param formattedSegment
	 *            the formatted Segment; plaintextsegment is set to the
	 *            formattedSegment
	 * @param language
	 *            the language of the segment
	 */
	public MonoLingualObject(String formattedSegment, String language)
	{
		super();
		this.setFormattedSegment(formattedSegment);
		this.setPlainTextSegment(simpleComputePlainText(formattedSegment));
		this.language = language;
	}

	/**
	 * @param formattedSegment
	 *            the formatted segment
	 * @param language
	 *            the language of the segment
	 * @param classname
	 *            a Class object which contains the method determinePlaintext
	 *            (best declared static!)
	 * @param determinePlaintext
	 *            the method which computes the plain text (arguments supplied
	 *            are: formatted string and an object for any additional
	 *            parameters needed
	 * @param params
	 *            the additional parameter (Object) for controlling the
	 *            computation of the plain text string
	 */
	public MonoLingualObject(String formattedSegment, String language, @SuppressWarnings("rawtypes") Class classname, Method determinePlaintext, Object params)
	{
		super();
		this.setFormattedSegment(formattedSegment);
		try
		{
			this.plainTextSegment = (String) determinePlaintext.invoke(classname, formattedSegment, params); // ok,
			// here
			// we
			// need
			// to
			// call
			// a
			// function
			// to
			// compute
			// the plain text of the formatted String
			this.setPlainTextSegment(plainTextSegment);
		}
		catch (IllegalArgumentException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (IllegalAccessException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (InvocationTargetException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		this.language = language;
	}

	/**
	 * @param formattedSegment
	 * @param plainTextSegment
	 * @param language
	 */
	public MonoLingualObject(String formattedSegment, String plainTextSegment, String language)
	{
		super();
		this.setFormattedSegment(formattedSegment);
		this.setPlainTextSegment(plainTextSegment);
		this.language = language;
	}

	/**
	 * bCompare compare this MOL against another MOL
	 * 
	 * @param molObj
	 *            the MOL to compare against
	 * @return true if the formattedSegment and language and
	 *         LinguisticProperties match (without core GeneralLinguisticObject
	 *         attributes)
	 */
	public boolean bCompare(MonoLingualObject molObj)
	{
		return bCompare(molObj, false);
	}

	/**
	 * bCompare compare this MOL against another MOL
	 * 
	 * @param genObj
	 *            the MOL to compare against
	 * @param bCompareCoreAttributes
	 * @return true if the formattedSegment and language and
	 *         LinguisticProperties match (including the core
	 *         GeneralLinguisticObject attributes)
	 */
	public boolean bCompare(MonoLingualObject molObj, boolean bCompareCoreAttributes)
	{
		if (molObj == null)
			return false;

		if (!this.language.equals(molObj.language))
			return false;
		if (!this.formattedSegment.equals(molObj.formattedSegment))
			return false;
		return super.bCompare(molObj, bCompareCoreAttributes);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.folt.models.datamodel.GeneralLinguisticObject#clearObject()
	 */
	@Override
	public void clearObject()
	{
		// TODO Auto-generated method stub
		super.clearObject();
		this.formattedSegment = null;
		this.language = null;
		this.parentMultiLingualObject = null;
		this.plainTextSegment = null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.folt.models.datamodel.GeneralLinguisticObject#format()
	 */
	public String format()
	{
		String str = "";
		str = str + "\tMonoLingualObject:\n\t\tFO -> \"" + this.formattedSegment + "\"\n\t\tPL -> \"" + this.plainTextSegment + "\"\n\t\tLang ->"
				+ this.language + "\n";
		return str + super.format();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.folt.models.datamodel.GeneralLinguisticObject#formatAsXml()
	 */
	public String formatAsXml()
	{
		String str = "";
		str = str + "<MonoLingualObject><formattedSegment>" + this.formattedSegment + "<formattedSegment>\n<plainTextSegment>"
				+ this.plainTextSegment + "</plainTextSegment>\n<Lang>" + this.language + "</Lang>\n";
		return str + super.formatAsXml() + "</MonoLingualObject>";
	}

	/**
	 * @return the formattedSegment
	 * @uml.property name="formattedSegment"
	 */
	@Column(name = "getFormattedSegment")
	public String getFormattedSegment()
	{
		return formattedSegment;
	}

	/**
	 * @return the language
	 */
	@Column(name = "language")
	public String getLanguage()
	{
		return language;
	}

	/**
	 * @return the parentMultiLingualObject
	 */
	@ManyToOne(optional = true)
	@JoinColumn(name = "MultiLingualObject_fk")
	public MultiLingualObject getParentMultiLingualObject()
	{
		return parentMultiLingualObject;
	}

	/**
	 * @return the plainTextSegment
	 * @uml.property name="plainTextSegment"
	 */
	@Column(name = "plainTextSegment")
	public String getPlainTextSegment()
	{
		if (plainTextSegment == null || plainTextSegment.equals(""))
			return this.getFormattedSegment();
		return plainTextSegment;
	}

	/**
	 * mapToJson
	 * 
	 * @return
	 */
	public String mapToJson()
	{
		JSONSerializer serializer = new JSONSerializer();
		String result = serializer.deepSerialize(this);
		return result;
	}

	/**
	 * mapToTig
	 * 
	 * @return
	 */
	public String mapToTig()
	{
		String tuv = "\t<langSet xml:lang=\"" + this.getLanguage() + "\">\n\t\t<tig>\n";
		String seg = "\t\t\t<term>" + this.getPlainTextSegment() + "</term>\n";
		tuv = tuv + seg;
		tuv = tuv + "\t\t</tig>\n\t</langSet>\n";
		return tuv;
	}

	/**
	 * mapToTuv converts the MonoLingualObject into a tuv formatted string
	 * 
	 * @return the tuv string
	 */
	public String mapToTuv()
	{
		String coreAttributes = ((LinguisticProperties) this.getLinguisticProperties()).formatCoreAttributesToTmx();
		String tuv = "\t\t<tuv xml:lang=\"" + this.getLanguage() + "\" " + coreAttributes + ">\n";

		tuv = tuv + ((LinguisticProperties) this.getLinguisticProperties()).formatNotePropToTmx();
		// the following fileds are now written in formatNotePropToTmx - 26.02.2012
		// tuv = tuv +  "\t\t\t<prop type=\"lastAccessTime\">" + this.lastAccessTime + "</prop>\n";
		// tuv = tuv +  "\t\t\t<prop type=\"internal-id\">" + this.id + "</prop>\n";
		// tuv = tuv +  "\t\t\t<prop type=\"unique-id\">" + this.getStUniqueID() + "</prop>\n";
		String seg = "\t\t\t<seg>" + this.getFormattedSegment() + "</seg>\n";
		tuv = tuv + seg;
		tuv = tuv + "\t\t</tuv>\n";
		return tuv;
	}

	/**
	 * @param formattedSegment
	 *            the formattedSegment to set
	 * @uml.property name="formattedSegment"
	 */
	public void setFormattedSegment(String formattedSegment)
	{
		this.formattedSegment = formattedSegment;
		setChanged();
		this.notifyObservers(this);
	}

	/**
	 * @param language
	 *            the language to set
	 */
	public void setLanguage(String language)
	{
		this.language = language;
		setChanged();
		this.notifyObservers(this);
	}

	/**
	 * @param parentMultiLingualObject
	 *            the parentMultiLingualObject to set
	 */
	public void setParentMultiLingualObject(MultiLingualObject parentMultiLingualObject)
	{
		this.parentMultiLingualObject = parentMultiLingualObject;
	}

	/**
	 * @param plainTextSegment
	 *            the plainTextSegment to set; the plain text segment is set to
	 *            null if it is identical to the formattedSegment
	 * @uml.property name="plainTextSegment"
	 */
	public void setPlainTextSegment(String plainTextSegment)
	{
		if ((this.formattedSegment != null) && !plainTextSegment.equals(this.formattedSegment))
			this.plainTextSegment = plainTextSegment;
		else
			plainTextSegment = null;

		// this.plainTextSegment = plainTextSegment;
		setChanged();
		this.notifyObservers(this);
	}
}
